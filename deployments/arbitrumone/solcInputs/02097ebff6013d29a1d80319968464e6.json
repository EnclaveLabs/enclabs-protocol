{
  "language": "Solidity",
  "sources": {
    "contracts/ECLVault/ECLStore.sol": {
      "content": "pragma solidity 0.5.16;\r\nimport \"../Utils/SafeERC20.sol\";\r\nimport \"../Utils/IERC20.sol\";\r\n\r\n/**\r\n * @title ECL Store\r\n * @author Venus\r\n * @notice ECL Store responsible for distributing ECL rewards\r\n */\r\ncontract ECLStore {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice The Admin Address\r\n    address public admin;\r\n\r\n    /// @notice The pending admin address\r\n    address public pendingAdmin;\r\n\r\n    /// @notice The Owner Address\r\n    address public owner;\r\n\r\n    /// @notice The reward tokens\r\n    mapping(address => bool) public rewardTokens;\r\n\r\n    /// @notice Emitted when pendingAdmin is changed\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /// @notice Event emitted when admin changed\r\n    event AdminTransferred(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    /// @notice Event emitted when owner changed\r\n    event OwnerTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner can\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Safely transfer rewards. Only active reward tokens can be sent using this function.\r\n     * Only callable by owner\r\n     * @dev Safe reward token transfer function, just in case if rounding error causes pool to not have enough tokens.\r\n     * @param token Reward token to transfer\r\n     * @param _to Destination address of the reward\r\n     * @param _amount Amount to transfer\r\n     */\r\n    function safeRewardTransfer(address token, address _to, uint256 _amount) external onlyOwner {\r\n        require(rewardTokens[token] == true, \"only reward token can\");\r\n\r\n        if (address(token) != address(0)) {\r\n            uint256 tokenBalance = IERC20(token).balanceOf(address(this));\r\n            if (_amount > tokenBalance) {\r\n                IERC20(token).safeTransfer(_to, tokenBalance);\r\n            } else {\r\n                IERC20(token).safeTransfer(_to, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the admin to propose a new admin\r\n     * Only callable admin\r\n     * @param _admin Propose an account as admin of the ECL store\r\n     */\r\n    function setPendingAdmin(address _admin) external onlyAdmin {\r\n        address oldPendingAdmin = pendingAdmin;\r\n        pendingAdmin = _admin;\r\n        emit NewPendingAdmin(oldPendingAdmin, _admin);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an account that is pending as admin to accept the role\r\n     * nly calllable by the pending admin\r\n     */\r\n    function acceptAdmin() external {\r\n        require(msg.sender == pendingAdmin, \"only pending admin\");\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n        emit AdminTransferred(oldAdmin, admin);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the contract owner\r\n     * @param _owner The address of the owner to set\r\n     * Only callable admin\r\n     */\r\n    function setNewOwner(address _owner) external onlyAdmin {\r\n        require(_owner != address(0), \"new owner is the zero address\");\r\n        address oldOwner = owner;\r\n        owner = _owner;\r\n        emit OwnerTransferred(oldOwner, _owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Set or disable a reward token\r\n     * @param _tokenAddress The address of a token to set as active or inactive\r\n     * @param status Set whether a reward token is active or not\r\n     */\r\n    function setRewardToken(address _tokenAddress, bool status) external {\r\n        require(msg.sender == admin || msg.sender == owner, \"only admin or owner can\");\r\n        rewardTokens[_tokenAddress] = status;\r\n    }\r\n\r\n    /**\r\n     * @notice Security function to allow the owner of the contract to withdraw from the contract\r\n     * @param _tokenAddress Reward token address to withdraw\r\n     * @param _amount Amount of token to withdraw\r\n     */\r\n    function emergencyRewardWithdraw(address _tokenAddress, uint256 _amount) external onlyOwner {\r\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _amount);\r\n    }\r\n}"
    },
    "contracts/ECLVault/ECLVaultErrorReporter.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ncontract ECLVaultErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK\r\n    }\r\n\r\n    /**\r\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n     **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n     */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n     */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}"
    },
    "contracts/ECLVault/ECLVaultProxy.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./ECLVaultStorage.sol\";\r\nimport \"./ECLVaultErrorReporter.sol\";\r\n\r\n/**\r\n * @title ECL Vault Proxy\r\n * @author Venus\r\n * @notice ECL Vault Proxy contract\r\n */\r\ncontract ECLVaultProxy is ECLVaultAdminStorage, ECLVaultErrorReporter {\r\n    /**\r\n     * @notice Emitted when pendingECLVaultImplementation is changed\r\n     */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n     * @notice Emitted when pendingECLVaultImplementation is accepted, which means ECL Vault implementation is updated\r\n     */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n     * @notice Emitted when pendingAdmin is changed\r\n     */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n     */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() public {\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingECLVaultImplementation;\r\n\r\n        pendingECLVaultImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingECLVaultImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accepts new implementation of ECL Vault. msg.sender must be pendingImplementation\r\n     * @dev Admin function for new implementation to accept it's role as implementation\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _acceptImplementation() public returns (uint) {\r\n        // Check caller is pendingImplementation\r\n        if (msg.sender != pendingECLVaultImplementation) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = implementation;\r\n        address oldPendingImplementation = pendingECLVaultImplementation;\r\n\r\n        implementation = pendingECLVaultImplementation;\r\n\r\n        pendingECLVaultImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingECLVaultImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n     * @param newPendingAdmin New pending admin.\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n     * @dev Admin function for pending admin to accept role and update admin\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller is pendingAdmin\r\n        if (msg.sender != pendingAdmin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function() external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n            switch success\r\n            case 0 {\r\n                revert(free_mem_ptr, returndatasize)\r\n            }\r\n            default {\r\n                return(free_mem_ptr, returndatasize)\r\n            }\r\n        }\r\n    }\r\n}"
    },
    "contracts/ECLVault/ECLVaults.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../Utils/ECDSA.sol\";\r\nimport \"../Utils/SafeERC20.sol\";\r\nimport \"../Utils/IERC20.sol\";\r\nimport \"./ECLVaultStorage.sol\";\r\nimport \"../Utils/SafeCast.sol\";\r\nimport \"../Governance/AccessControlledV5.sol\";\r\nimport \"../Governance/TimeManagerV5.sol\";\r\n\r\nimport { ECLStore } from \"./ECLStore.sol\";\r\nimport { ECLVaultProxy } from \"./ECLVaultProxy.sol\";\r\n\r\n/**\r\n * @title ECL Vault\r\n * @author Venus\r\n * @notice The ECL Vault allows ECL holders to lock their ECL to recieve voting rights in Venus governance and are rewarded with ECL.\r\n */\r\ncontract ECLVault is ECLVaultStorage, ECDSA, AccessControlledV5, TimeManagerV5 {\r\n    using SafeMath for uint256;\r\n    using SafeCast for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice The upper bound for the lock period in a pool, 10 years\r\n    uint256 public constant MAX_LOCK_PERIOD = 60 * 60 * 24 * 365 * 10;\r\n\r\n    /// @notice Event emitted when deposit\r\n    event Deposit(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\r\n\r\n    /// @notice Event emitted when execute withrawal\r\n    event ExecutedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\r\n\r\n    /// @notice Event emitted when request withrawal\r\n    event RequestedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChangedV2(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChangedV2(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /// @notice An event emitted when the reward store address is updated\r\n    event StoreUpdated(address oldEcl, address oldStore, address newEcl, address newStore);\r\n\r\n    /// @notice An event emitted when the withdrawal locking period is updated for a pool\r\n    event WithdrawalLockingPeriodUpdated(address indexed rewardToken, uint indexed pid, uint oldPeriod, uint newPeriod);\r\n\r\n    /// @notice An event emitted when the reward amount per block or second is modified for a pool\r\n    event RewardAmountUpdated(address indexed rewardToken, uint oldReward, uint newReward);\r\n\r\n    /// @notice An event emitted when a new pool is added\r\n    event PoolAdded(\r\n        address indexed rewardToken,\r\n        uint indexed pid,\r\n        address indexed token,\r\n        uint allocPoints,\r\n        uint rewardPerBlockOrSecond,\r\n        uint lockPeriod\r\n    );\r\n\r\n    /// @notice An event emitted when a pool allocation points are updated\r\n    event PoolUpdated(address indexed rewardToken, uint indexed pid, uint oldAllocPoints, uint newAllocPoints);\r\n\r\n    /// @notice Event emitted when reward claimed\r\n    event Claim(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\r\n\r\n    /// @notice Event emitted when vault is paused\r\n    event VaultPaused(address indexed admin);\r\n\r\n    /// @notice Event emitted when vault is resumed after pause\r\n    event VaultResumed(address indexed admin);\r\n\r\n    /// @notice Event emitted when protocol logs a debt to a user due to insufficient funds for pending reward distribution\r\n    event VaultDebtUpdated(\r\n        address indexed rewardToken,\r\n        address indexed userAddress,\r\n        uint256 oldOwedAmount,\r\n        uint256 newOwedAmount\r\n    );\r\n\r\n    /**\r\n     * @notice ECLVault constructor\r\n     */\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents functions to execute when vault is paused.\r\n     */\r\n    modifier isActive() {\r\n        require(!vaultPaused, \"Vault is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Pauses vault\r\n     */\r\n    function pause() external {\r\n        _checkAccessAllowed(\"pause()\");\r\n        require(!vaultPaused, \"Vault is already paused\");\r\n        vaultPaused = true;\r\n        emit VaultPaused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Resume vault\r\n     */\r\n    function resume() external {\r\n        _checkAccessAllowed(\"resume()\");\r\n        require(vaultPaused, \"Vault is not paused\");\r\n        vaultPaused = false;\r\n        emit VaultResumed(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of pools with the specified reward token\r\n     * @param rewardToken Reward token address\r\n     * @return Number of pools that distribute the specified token as a reward\r\n     */\r\n    function poolLength(address rewardToken) external view returns (uint256) {\r\n        return poolInfos[rewardToken].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of reward tokens created per block or second\r\n     * @param _rewardToken Reward token address\r\n     * @return Number of reward tokens created per block or second\r\n     */\r\n    function rewardTokenAmountsPerBlock(address _rewardToken) external view returns (uint256) {\r\n        return rewardTokenAmountsPerBlockOrSecond[_rewardToken];\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new token pool\r\n     * @dev This vault DOES NOT support deflationary tokens â€” it expects that\r\n     *   the amount of transferred tokens would equal the actually deposited\r\n     *   amount. In practice this means that this vault DOES NOT support USDT\r\n     *   and similar tokens (that do not provide these guarantees).\r\n     * @param _rewardToken Reward token address\r\n     * @param _allocPoint Number of allocation points assigned to this pool\r\n     * @param _token Staked token\r\n     * @param _rewardPerBlockOrSecond Initial reward per block or second, in terms of _rewardToken\r\n     * @param _lockPeriod A period between withdrawal request and a moment when it's executable\r\n     */\r\n    function add(\r\n        address _rewardToken,\r\n        uint256 _allocPoint,\r\n        IERC20 _token,\r\n        uint256 _rewardPerBlockOrSecond,\r\n        uint256 _lockPeriod\r\n    ) external {\r\n        _checkAccessAllowed(\"add(address,uint256,address,uint256,uint256)\");\r\n        _ensureNonzeroAddress(_rewardToken);\r\n        _ensureNonzeroAddress(address(_token));\r\n        require(address(eclStore) != address(0), \"Store contract address is empty\");\r\n        require(_allocPoint > 0, \"Alloc points must not be zero\");\r\n\r\n        massUpdatePools(_rewardToken);\r\n\r\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\r\n\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            require(poolInfo[pid].token != _token, \"Pool already added\");\r\n        }\r\n\r\n        // We use balanceOf to get the supply amount, so shouldn't be possible to\r\n        // configure pools with different reward token but the same staked token\r\n        require(!isStakedToken[address(_token)], \"Token exists in other pool\");\r\n\r\n        totalAllocPoints[_rewardToken] = totalAllocPoints[_rewardToken].add(_allocPoint);\r\n\r\n        rewardTokenAmountsPerBlockOrSecond[_rewardToken] = _rewardPerBlockOrSecond;\r\n\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                token: _token,\r\n                allocPoint: _allocPoint,\r\n                lastRewardBlockOrSecond: getBlockNumberOrTimestamp(),\r\n                accRewardPerShare: 0,\r\n                lockPeriod: _lockPeriod\r\n            })\r\n        );\r\n        isStakedToken[address(_token)] = true;\r\n\r\n        ECLStore(eclStore).setRewardToken(_rewardToken, true);\r\n\r\n        emit PoolAdded(\r\n            _rewardToken,\r\n            poolInfo.length - 1,\r\n            address(_token),\r\n            _allocPoint,\r\n            _rewardPerBlockOrSecond,\r\n            _lockPeriod\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update the given pool's reward allocation point\r\n     * @param _rewardToken Reward token address\r\n     * @param _pid Pool index\r\n     * @param _allocPoint Number of allocation points assigned to this pool\r\n     */\r\n    function set(address _rewardToken, uint256 _pid, uint256 _allocPoint) external {\r\n        _checkAccessAllowed(\"set(address,uint256,uint256)\");\r\n        _ensureValidPool(_rewardToken, _pid);\r\n\r\n        massUpdatePools(_rewardToken);\r\n\r\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\r\n        uint256 newTotalAllocPoints = totalAllocPoints[_rewardToken].sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        require(newTotalAllocPoints > 0, \"Alloc points per reward token must not be zero\");\r\n\r\n        uint256 oldAllocPoints = poolInfo[_pid].allocPoint;\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n        totalAllocPoints[_rewardToken] = newTotalAllocPoints;\r\n\r\n        emit PoolUpdated(_rewardToken, _pid, oldAllocPoints, _allocPoint);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the given reward token's amount per block or second\r\n     * @param _rewardToken Reward token address\r\n     * @param _rewardAmount Number of allocation points assigned to this pool\r\n     */\r\n    function setRewardAmountPerBlockOrSecond(address _rewardToken, uint256 _rewardAmount) external {\r\n        _checkAccessAllowed(\"setRewardAmountPerBlockOrSecond(address,uint256)\");\r\n        require(ECLStore(eclStore).rewardTokens(_rewardToken), \"Invalid reward token\");\r\n        massUpdatePools(_rewardToken);\r\n        uint256 oldReward = rewardTokenAmountsPerBlockOrSecond[_rewardToken];\r\n        rewardTokenAmountsPerBlockOrSecond[_rewardToken] = _rewardAmount;\r\n\r\n        emit RewardAmountUpdated(_rewardToken, oldReward, _rewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the lock period after which a requested withdrawal can be executed\r\n     * @param _rewardToken Reward token address\r\n     * @param _pid Pool index\r\n     * @param _newPeriod New lock period\r\n     */\r\n    function setWithdrawalLockingPeriod(address _rewardToken, uint256 _pid, uint256 _newPeriod) external {\r\n        _checkAccessAllowed(\"setWithdrawalLockingPeriod(address,uint256,uint256)\");\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        require(_newPeriod > 0 && _newPeriod < MAX_LOCK_PERIOD, \"Invalid new locking period\");\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        uint256 oldPeriod = pool.lockPeriod;\r\n        pool.lockPeriod = _newPeriod;\r\n\r\n        emit WithdrawalLockingPeriodUpdated(_rewardToken, _pid, oldPeriod, _newPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit ECLVault for ECL allocation\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _amount The amount to deposit to vault\r\n     */\r\n    function deposit(address _rewardToken, uint256 _pid, uint256 _amount) external nonReentrant isActive {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\r\n        _updatePool(_rewardToken, _pid);\r\n        require(pendingWithdrawalsBeforeUpgrade(_rewardToken, _pid, msg.sender) == 0, \"execute pending withdrawal\");\r\n\r\n        if (user.amount > 0) {\r\n            uint256 pending = _computeReward(user, pool);\r\n            if (pending > 0) {\r\n                _transferReward(_rewardToken, msg.sender, pending);\r\n                emit Claim(msg.sender, _rewardToken, _pid, pending);\r\n            }\r\n        }\r\n        pool.token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        user.amount = user.amount.add(_amount);\r\n        user.rewardDebt = _cumulativeReward(user, pool);\r\n\r\n        // Update Delegate Amount\r\n        if (address(pool.token) == eclAddress) {\r\n            _moveDelegates(address(0), delegates[msg.sender], safe96(_amount, \"ECLVault::deposit: votes overflow\"));\r\n        }\r\n\r\n        emit Deposit(msg.sender, _rewardToken, _pid, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim rewards for pool\r\n     * @param _account The account for which to claim rewards\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     */\r\n    function claim(address _account, address _rewardToken, uint256 _pid) external nonReentrant isActive {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][_account];\r\n        _updatePool(_rewardToken, _pid);\r\n        require(pendingWithdrawalsBeforeUpgrade(_rewardToken, _pid, _account) == 0, \"execute pending withdrawal\");\r\n\r\n        if (user.amount > 0) {\r\n            uint256 pending = _computeReward(user, pool);\r\n\r\n            if (pending > 0) {\r\n                user.rewardDebt = _cumulativeReward(user, pool);\r\n\r\n                _transferReward(_rewardToken, _account, pending);\r\n                emit Claim(_account, _rewardToken, _pid, pending);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Pushes withdrawal request to the requests array and updates\r\n     *   the pending withdrawals amount. The requests are always sorted\r\n     *   by unlock time (descending) so that the earliest to execute requests\r\n     *   are always at the end of the array.\r\n     * @param _user The user struct storage pointer\r\n     * @param _requests The user's requests array storage pointer\r\n     * @param _amount The amount being requested\r\n     */\r\n    function pushWithdrawalRequest(\r\n        UserInfo storage _user,\r\n        WithdrawalRequest[] storage _requests,\r\n        uint _amount,\r\n        uint _lockedUntil\r\n    ) internal {\r\n        uint i = _requests.length;\r\n        _requests.push(WithdrawalRequest(0, 0, 1));\r\n        // Keep it sorted so that the first to get unlocked request is always at the end\r\n        for (; i > 0 && _requests[i - 1].lockedUntil <= _lockedUntil; --i) {\r\n            _requests[i] = _requests[i - 1];\r\n        }\r\n        _requests[i] = WithdrawalRequest(_amount, _lockedUntil.toUint128(), 1);\r\n        _user.pendingWithdrawals = _user.pendingWithdrawals.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Pops the requests with unlock time < now from the requests\r\n     *   array and deducts the computed amount from the user's pending\r\n     *   withdrawals counter. Assumes that the requests array is sorted\r\n     *   by unclock time (descending).\r\n     * @dev This function **removes** the eligible requests from the requests\r\n     *   array. If this function is called, the withdrawal should actually\r\n     *   happen (or the transaction should be reverted).\r\n     * @param _user The user struct storage pointer\r\n     * @param _requests The user's requests array storage pointer\r\n     * @return beforeUpgradeWithdrawalAmount The amount eligible for withdrawal before upgrade (this amount should be\r\n     *   sent to the user, otherwise the state would be inconsistent).\r\n     * @return afterUpgradeWithdrawalAmount The amount eligible for withdrawal after upgrade (this amount should be\r\n     *   sent to the user, otherwise the state would be inconsistent).\r\n     */\r\n    function popEligibleWithdrawalRequests(\r\n        UserInfo storage _user,\r\n        WithdrawalRequest[] storage _requests\r\n    ) internal returns (uint beforeUpgradeWithdrawalAmount, uint afterUpgradeWithdrawalAmount) {\r\n        // Since the requests are sorted by their unlock time, we can just\r\n        // pop them from the array and stop at the first not-yet-eligible one\r\n        for (uint i = _requests.length; i > 0 && isUnlocked(_requests[i - 1]); --i) {\r\n            if (_requests[i - 1].afterUpgrade == 1) {\r\n                afterUpgradeWithdrawalAmount = afterUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\r\n            } else {\r\n                beforeUpgradeWithdrawalAmount = beforeUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\r\n            }\r\n\r\n            _requests.pop();\r\n        }\r\n        _user.pendingWithdrawals = _user.pendingWithdrawals.sub(\r\n            afterUpgradeWithdrawalAmount.add(beforeUpgradeWithdrawalAmount)\r\n        );\r\n        return (beforeUpgradeWithdrawalAmount, afterUpgradeWithdrawalAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the request is eligible for withdrawal.\r\n     * @param _request The request struct storage pointer\r\n     * @return True if the request is eligible for withdrawal, false otherwise\r\n     */\r\n    function isUnlocked(WithdrawalRequest storage _request) private view returns (bool) {\r\n        return _request.lockedUntil <= block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute withdrawal to ECLVault for ECL allocation\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     */\r\n    function executeWithdrawal(address _rewardToken, uint256 _pid) external nonReentrant isActive {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\r\n\r\n        uint256 beforeUpgradeWithdrawalAmount;\r\n        uint256 afterUpgradeWithdrawalAmount;\r\n\r\n        (beforeUpgradeWithdrawalAmount, afterUpgradeWithdrawalAmount) = popEligibleWithdrawalRequests(user, requests);\r\n        require(beforeUpgradeWithdrawalAmount > 0 || afterUpgradeWithdrawalAmount > 0, \"nothing to withdraw\");\r\n\r\n        // Having both old-style and new-style requests is not allowed and shouldn't be possible\r\n        require(beforeUpgradeWithdrawalAmount == 0 || afterUpgradeWithdrawalAmount == 0, \"inconsistent state\");\r\n\r\n        if (beforeUpgradeWithdrawalAmount > 0) {\r\n            _updatePool(_rewardToken, _pid);\r\n            uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);\r\n            ECLStore(eclStore).safeRewardTransfer(_rewardToken, msg.sender, pending);\r\n            user.amount = user.amount.sub(beforeUpgradeWithdrawalAmount);\r\n            user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\r\n            pool.token.safeTransfer(address(msg.sender), beforeUpgradeWithdrawalAmount);\r\n        } else {\r\n            user.amount = user.amount.sub(afterUpgradeWithdrawalAmount);\r\n            totalPendingWithdrawals[_rewardToken][_pid] = totalPendingWithdrawals[_rewardToken][_pid].sub(\r\n                afterUpgradeWithdrawalAmount\r\n            );\r\n            pool.token.safeTransfer(address(msg.sender), afterUpgradeWithdrawalAmount);\r\n        }\r\n\r\n        emit ExecutedWithdrawal(\r\n            msg.sender,\r\n            _rewardToken,\r\n            _pid,\r\n            beforeUpgradeWithdrawalAmount.add(afterUpgradeWithdrawalAmount)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns before and after upgrade pending withdrawal amount\r\n     * @param _requests The user's requests array storage pointer\r\n     * @return beforeUpgradeWithdrawalAmount The amount eligible for withdrawal before upgrade\r\n     * @return afterUpgradeWithdrawalAmount The amount eligible for withdrawal after upgrade\r\n     */\r\n    function getRequestedWithdrawalAmount(\r\n        WithdrawalRequest[] storage _requests\r\n    ) internal view returns (uint beforeUpgradeWithdrawalAmount, uint afterUpgradeWithdrawalAmount) {\r\n        for (uint i = _requests.length; i > 0; --i) {\r\n            if (_requests[i - 1].afterUpgrade == 1) {\r\n                afterUpgradeWithdrawalAmount = afterUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\r\n            } else {\r\n                beforeUpgradeWithdrawalAmount = beforeUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\r\n            }\r\n        }\r\n        return (beforeUpgradeWithdrawalAmount, afterUpgradeWithdrawalAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Request withdrawal to ECLVault for ECL allocation\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _amount The amount to withdraw from the vault\r\n     */\r\n    function requestWithdrawal(address _rewardToken, uint256 _pid, uint256 _amount) external nonReentrant isActive {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        require(_amount > 0, \"requested amount cannot be zero\");\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\r\n        require(user.amount >= user.pendingWithdrawals.add(_amount), \"requested amount is invalid\");\r\n\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\r\n\r\n        uint beforeUpgradeWithdrawalAmount;\r\n\r\n        (beforeUpgradeWithdrawalAmount, ) = getRequestedWithdrawalAmount(requests);\r\n        require(beforeUpgradeWithdrawalAmount == 0, \"execute pending withdrawal\");\r\n\r\n        _updatePool(_rewardToken, _pid);\r\n        uint256 pending = _computeReward(user, pool);\r\n        _transferReward(_rewardToken, msg.sender, pending);\r\n\r\n        uint lockedUntil = pool.lockPeriod.add(block.timestamp);\r\n\r\n        pushWithdrawalRequest(user, requests, _amount, lockedUntil);\r\n        totalPendingWithdrawals[_rewardToken][_pid] = totalPendingWithdrawals[_rewardToken][_pid].add(_amount);\r\n        user.rewardDebt = _cumulativeReward(user, pool);\r\n\r\n        // Update Delegate Amount\r\n        if (address(pool.token) == eclAddress) {\r\n            _moveDelegates(\r\n                delegates[msg.sender],\r\n                address(0),\r\n                safe96(_amount, \"ECLVault::requestWithdrawal: votes overflow\")\r\n            );\r\n        }\r\n\r\n        emit Claim(msg.sender, _rewardToken, _pid, pending);\r\n        emit RequestedWithdrawal(msg.sender, _rewardToken, _pid, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get unlocked withdrawal amount\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _user The User Address\r\n     * @return withdrawalAmount Amount that the user can withdraw\r\n     */\r\n    function getEligibleWithdrawalAmount(\r\n        address _rewardToken,\r\n        uint256 _pid,\r\n        address _user\r\n    ) external view returns (uint withdrawalAmount) {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\r\n        // Since the requests are sorted by their unlock time, we can take\r\n        // the entries from the end of the array and stop at the first\r\n        // not-yet-eligible one\r\n        for (uint i = requests.length; i > 0 && isUnlocked(requests[i - 1]); --i) {\r\n            withdrawalAmount = withdrawalAmount.add(requests[i - 1].amount);\r\n        }\r\n        return withdrawalAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Get requested amount\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _user The User Address\r\n     * @return Total amount of requested but not yet executed withdrawals (including both executable and locked ones)\r\n     */\r\n    function getRequestedAmount(address _rewardToken, uint256 _pid, address _user) external view returns (uint256) {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\r\n        return user.pendingWithdrawals;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the array of withdrawal requests that have not been executed yet\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _user The User Address\r\n     * @return An array of withdrawal requests\r\n     */\r\n    function getWithdrawalRequests(\r\n        address _rewardToken,\r\n        uint256 _pid,\r\n        address _user\r\n    ) external view returns (WithdrawalRequest[] memory) {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        return withdrawalRequests[_rewardToken][_pid][_user];\r\n    }\r\n\r\n    /**\r\n     * @notice View function to see pending ECLs on frontend\r\n     * @param _rewardToken Reward token address\r\n     * @param _pid Pool index\r\n     * @param _user User address\r\n     * @return Reward the user is eligible for in this pool, in terms of _rewardToken\r\n     */\r\n    function pendingReward(address _rewardToken, uint256 _pid, address _user) external view returns (uint256) {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\r\n        uint256 accRewardPerShare = pool.accRewardPerShare;\r\n        uint256 supply = pool.token.balanceOf(address(this)).sub(totalPendingWithdrawals[_rewardToken][_pid]);\r\n        uint256 curBlockNumberOrSecond = getBlockNumberOrTimestamp();\r\n        uint256 rewardTokenPerBlockOrSecond = rewardTokenAmountsPerBlockOrSecond[_rewardToken];\r\n        if (curBlockNumberOrSecond > pool.lastRewardBlockOrSecond && supply != 0) {\r\n            uint256 multiplier = curBlockNumberOrSecond.sub(pool.lastRewardBlockOrSecond);\r\n            uint256 reward = multiplier.mul(rewardTokenPerBlockOrSecond).mul(pool.allocPoint).div(\r\n                totalAllocPoints[_rewardToken]\r\n            );\r\n            accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(supply));\r\n        }\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\r\n        (, uint256 afterUpgradeWithdrawalAmount) = getRequestedWithdrawalAmount(requests);\r\n        return user.amount.sub(afterUpgradeWithdrawalAmount).mul(accRewardPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools(address _rewardToken) internal {\r\n        uint256 length = poolInfos[_rewardToken].length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            _updatePool(_rewardToken, pid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update reward variables of the given pool to be up-to-date\r\n     * @param _rewardToken Reward token address\r\n     * @param _pid Pool index\r\n     */\r\n    function updatePool(address _rewardToken, uint256 _pid) external isActive {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        _updatePool(_rewardToken, _pid);\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function _updatePool(address _rewardToken, uint256 _pid) internal {\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        if (getBlockNumberOrTimestamp() <= pool.lastRewardBlockOrSecond) {\r\n            return;\r\n        }\r\n        uint256 supply = pool.token.balanceOf(address(this));\r\n        supply = supply.sub(totalPendingWithdrawals[_rewardToken][_pid]);\r\n        if (supply == 0) {\r\n            pool.lastRewardBlockOrSecond = getBlockNumberOrTimestamp();\r\n            return;\r\n        }\r\n        uint256 curBlockNumberOrSecond = getBlockNumberOrTimestamp();\r\n        uint256 multiplier = curBlockNumberOrSecond.sub(pool.lastRewardBlockOrSecond);\r\n        uint256 reward = multiplier.mul(rewardTokenAmountsPerBlockOrSecond[_rewardToken]).mul(pool.allocPoint).div(\r\n            totalAllocPoints[_rewardToken]\r\n        );\r\n        pool.accRewardPerShare = pool.accRewardPerShare.add(reward.mul(1e12).div(supply));\r\n        pool.lastRewardBlockOrSecond = getBlockNumberOrTimestamp();\r\n    }\r\n\r\n    function _ensureValidPool(address rewardToken, uint256 pid) internal view {\r\n        require(pid < poolInfos[rewardToken].length, \"vault: pool exists?\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get user info with reward token address and pid\r\n     * @param _rewardToken Reward token address\r\n     * @param _pid Pool index\r\n     * @param _user User address\r\n     * @return amount Deposited amount\r\n     * @return rewardDebt Reward debt (technical value used to track past payouts)\r\n     * @return pendingWithdrawals Requested but not yet executed withdrawals\r\n     */\r\n    function getUserInfo(\r\n        address _rewardToken,\r\n        uint256 _pid,\r\n        address _user\r\n    ) external view returns (uint256 amount, uint256 rewardDebt, uint256 pendingWithdrawals) {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\r\n        amount = user.amount;\r\n        rewardDebt = user.rewardDebt;\r\n        pendingWithdrawals = user.pendingWithdrawals;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total pending withdrawal amount of a user before upgrade\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _user The address of the user\r\n     * @return beforeUpgradeWithdrawalAmount Total pending withdrawal amount in requests made before the vault upgrade\r\n     */\r\n    function pendingWithdrawalsBeforeUpgrade(\r\n        address _rewardToken,\r\n        uint256 _pid,\r\n        address _user\r\n    ) public view returns (uint256 beforeUpgradeWithdrawalAmount) {\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\r\n        (beforeUpgradeWithdrawalAmount, ) = getRequestedWithdrawalAmount(requests);\r\n        return beforeUpgradeWithdrawalAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the ECL stake balance of an account (excluding the pending withdrawals)\r\n     * @param account The address of the account to check\r\n     * @return The balance that user staked\r\n     */\r\n    function getStakeAmount(address account) internal view returns (uint96) {\r\n        require(eclAddress != address(0), \"ECLVault::getStakeAmount: ecl address is not set\");\r\n\r\n        PoolInfo[] storage poolInfo = poolInfos[eclAddress];\r\n\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            if (address(poolInfo[pid].token) == address(eclAddress)) {\r\n                UserInfo storage user = userInfos[eclAddress][pid][account];\r\n                return safe96(user.amount.sub(user.pendingWithdrawals), \"ECLVault::getStakeAmount: votes overflow\");\r\n            }\r\n        }\r\n        return uint96(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) external isActive {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(\r\n        address delegatee,\r\n        uint nonce,\r\n        uint expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external isActive {\r\n        bytes32 domainSeparator = keccak256(\r\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"ECLVault\")), getChainId(), address(this))\r\n        );\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ECDSA.recover(digest, v, r, s);\r\n        require(nonce == nonces[signatory]++, \"ECLVault::delegateBySig: invalid nonce\");\r\n        require(block.timestamp <= expiry, \"ECLVault::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint96) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        uint96 delegatorBalance = getStakeAmount(delegator);\r\n        delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChangedV2(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"ECLVault::_moveVotes: vote amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint96 dstRepNew = add96(dstRepOld, amount, \"ECLVault::_moveVotes: vote amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\r\n        uint32 blockNumberOrSecond = safe32(\r\n            getBlockNumberOrTimestamp(),\r\n            \"ECLVault::_writeCheckpoint: block number or second exceeds 32 bits\"\r\n        );\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlockOrSecond == blockNumberOrSecond) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumberOrSecond, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChangedV2(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2 ** 32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2 ** 96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return chainId;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the ecl stake balance for an account\r\n     * @param account The address of the account to check\r\n     * @param blockNumberOrSecond The block number or second to get the vote balance at\r\n     * @return The balance that user staked\r\n     */\r\n    function getPriorVotes(address account, uint256 blockNumberOrSecond) external view returns (uint96) {\r\n        require(blockNumberOrSecond < getBlockNumberOrTimestamp(), \"ECLVault::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlockOrSecond <= blockNumberOrSecond) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlockOrSecond > blockNumberOrSecond) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlockOrSecond == blockNumberOrSecond) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlockOrSecond < blockNumberOrSecond) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _become(ECLVaultProxy eclVaultProxy) external {\r\n        require(msg.sender == eclVaultProxy.admin(), \"only proxy admin can change brains\");\r\n        require(eclVaultProxy._acceptImplementation() == 0, \"change not authorized\");\r\n    }\r\n\r\n    function setEclStore(address _ecl, address _eclStore) external onlyAdmin {\r\n        _ensureNonzeroAddress(_ecl);\r\n        _ensureNonzeroAddress(_eclStore);\r\n\r\n        address oldEclContract = eclAddress;\r\n        address oldStore = eclStore;\r\n        require(oldEclContract == address(0), \"already initialized\");\r\n\r\n        eclAddress = _ecl;\r\n        eclStore = _eclStore;\r\n\r\n        _notEntered = true;\r\n\r\n        emit StoreUpdated(oldEclContract, oldStore, _ecl, _eclStore);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract to use either blocks or seconds\r\n     * @param timeBased_ A boolean indicating whether the contract is based on time or block\r\n     * If timeBased is true than blocksPerYear_ param is ignored as blocksOrSecondsPerYear is set to SECONDS_PER_YEAR\r\n     * @param blocksPerYear_ The number of blocks per year\r\n     */\r\n    function initializeTimeManager(bool timeBased_, uint256 blocksPerYear_) external onlyAdmin {\r\n        _initializeTimeManager(timeBased_, blocksPerYear_);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the access control of this contract\r\n     * @dev Admin function to set the access control address\r\n     * @param newAccessControlAddress New address for the access control\r\n     */\r\n    function setAccessControl(address newAccessControlAddress) external onlyAdmin {\r\n        _setAccessControlManager(newAccessControlAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the provided address is a zero address\r\n     * @param address_ Address to check\r\n     */\r\n    function _ensureNonzeroAddress(address address_) internal pure {\r\n        require(address_ != address(0), \"zero address not allowed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the reward to the user, taking into account the rewards store\r\n     *   balance and the previous debt. If there are not enough rewards in the store,\r\n     *   transfers the available funds and records the debt amount in pendingRewardTransfers.\r\n     * @param rewardToken Reward token address\r\n     * @param userAddress User address\r\n     * @param amount Reward amount, in reward tokens\r\n     */\r\n    function _transferReward(address rewardToken, address userAddress, uint256 amount) internal {\r\n        address eclStore_ = eclStore;\r\n        uint256 storeBalance = IERC20(rewardToken).balanceOf(eclStore_);\r\n        uint256 debtDueToFailedTransfers = pendingRewardTransfers[rewardToken][userAddress];\r\n        uint256 fullAmount = amount.add(debtDueToFailedTransfers);\r\n\r\n        if (fullAmount <= storeBalance) {\r\n            if (debtDueToFailedTransfers != 0) {\r\n                pendingRewardTransfers[rewardToken][userAddress] = 0;\r\n                emit VaultDebtUpdated(rewardToken, userAddress, debtDueToFailedTransfers, 0);\r\n            }\r\n            ECLStore(eclStore_).safeRewardTransfer(rewardToken, userAddress, fullAmount);\r\n            return;\r\n        }\r\n        // Overflow isn't possible due to the check above\r\n        uint256 newOwedAmount = fullAmount - storeBalance;\r\n        pendingRewardTransfers[rewardToken][userAddress] = newOwedAmount;\r\n        emit VaultDebtUpdated(rewardToken, userAddress, debtDueToFailedTransfers, newOwedAmount);\r\n        ECLStore(eclStore_).safeRewardTransfer(rewardToken, userAddress, storeBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes cumulative reward for all user's shares\r\n     * @param user UserInfo storage struct\r\n     * @param pool PoolInfo storage struct\r\n     */\r\n    function _cumulativeReward(UserInfo storage user, PoolInfo storage pool) internal view returns (uint256) {\r\n        return user.amount.sub(user.pendingWithdrawals).mul(pool.accRewardPerShare).div(1e12);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the reward for all user's shares\r\n     * @param user UserInfo storage struct\r\n     * @param pool PoolInfo storage struct\r\n     */\r\n    function _computeReward(UserInfo storage user, PoolInfo storage pool) internal view returns (uint256) {\r\n        return _cumulativeReward(user, pool).sub(user.rewardDebt);\r\n    }\r\n}"
    },
    "contracts/ECLVault/ECLVaultStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Utils/SafeMath.sol\";\r\nimport \"../Utils/IERC20.sol\";\r\n\r\ncontract ECLVaultAdminStorage {\r\n    /**\r\n     * @notice Administrator for this contract\r\n     */\r\n    address public admin;\r\n\r\n    /**\r\n     * @notice Pending administrator for this contract\r\n     */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n     * @notice Active brains of ECL Vault\r\n     */\r\n    address public implementation;\r\n\r\n    /**\r\n     * @notice Pending brains of ECL Vault\r\n     */\r\n    address public pendingECLVaultImplementation;\r\n}\r\n\r\ncontract ECLVaultStorageV1 is ECLVaultAdminStorage {\r\n    /// @notice Guard variable for re-entrancy checks\r\n    bool internal _notEntered;\r\n\r\n    /// @notice The reward token store\r\n    address public eclStore;\r\n\r\n    /// @notice The ecl token address\r\n    address public eclAddress;\r\n\r\n    // Reward tokens created per block or second indentified by reward token address.\r\n    mapping(address => uint256) public rewardTokenAmountsPerBlockOrSecond;\r\n\r\n    /// @notice Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n        uint256 pendingWithdrawals;\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 token; // Address of token contract to stake.\r\n        uint256 allocPoint; // How many allocation points assigned to this pool.\r\n        uint256 lastRewardBlockOrSecond; // Last block number or second that reward tokens distribution occurs.\r\n        uint256 accRewardPerShare; // Accumulated per share, times 1e12. See below.\r\n        uint256 lockPeriod; // Min time between withdrawal request and its execution.\r\n    }\r\n\r\n    // Infomation about a withdrawal request\r\n    struct WithdrawalRequest {\r\n        uint256 amount;\r\n        uint128 lockedUntil;\r\n        uint128 afterUpgrade;\r\n    }\r\n\r\n    // Info of each user that stakes tokens.\r\n    mapping(address => mapping(uint256 => mapping(address => UserInfo))) internal userInfos;\r\n\r\n    // Info of each pool.\r\n    mapping(address => PoolInfo[]) public poolInfos;\r\n\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    mapping(address => uint256) public totalAllocPoints;\r\n\r\n    // Info of requested but not yet executed withdrawals\r\n    mapping(address => mapping(uint256 => mapping(address => WithdrawalRequest[]))) internal withdrawalRequests;\r\n\r\n    /// @notice DEPRECATED A record of each accounts delegate (before the voting power fix)\r\n    mapping(address => address) private __oldDelegatesSlot;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block or second\r\n    struct Checkpoint {\r\n        uint32 fromBlockOrSecond;\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice DEPRECATED A record of votes checkpoints for each account, by index (before the voting power fix)\r\n    mapping(address => mapping(uint32 => Checkpoint)) private __oldCheckpointsSlot;\r\n\r\n    /// @notice DEPRECATED The number of checkpoints for each account (before the voting power fix)\r\n    mapping(address => uint32) private __oldNumCheckpointsSlot;\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping(address => uint) public nonces;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH =\r\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH =\r\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n}\r\n\r\ncontract ECLVaultStorage is ECLVaultStorageV1 {\r\n    /// @notice A record of each accounts delegate\r\n    mapping(address => address) public delegates;\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping(address => uint32) public numCheckpoints;\r\n\r\n    /// @notice Tracks pending withdrawals for all users for a particular reward token and pool id\r\n    mapping(address => mapping(uint256 => uint256)) public totalPendingWithdrawals;\r\n\r\n    /// @notice pause indicator for Vault\r\n    bool public vaultPaused;\r\n\r\n    /// @notice if the token is added to any of the pools\r\n    mapping(address => bool) public isStakedToken;\r\n\r\n    /// @notice Amount we owe to users because of failed transfer attempts\r\n    mapping(address => mapping(address => uint256)) public pendingRewardTransfers;\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[46] private __gap;\r\n}"
    },
    "contracts/Governance/AccessControlledV5.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity 0.5.16;\r\n\r\nimport \"./IAccessControlManagerV5.sol\";\r\n\r\n/**\r\n * @title AccessControlledV5\r\n * @author Venus\r\n * @notice This contract is helper between access control manager and actual contract. This contract further inherited by other contract (using solidity 0.5.16)\r\n * to integrate access controlled mechanism. It provides initialise methods and verifying access methods.\r\n */\r\ncontract AccessControlledV5 {\r\n    /// @notice Access control manager contract\r\n    IAccessControlManagerV5 private _accessControlManager;\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n\r\n    /// @notice Emitted when access control manager contract address is changed\r\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\r\n\r\n    /**\r\n     * @notice Returns the address of the access control manager contract\r\n     */\r\n    function accessControlManager() external view returns (IAccessControlManagerV5) {\r\n        return _accessControlManager;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set address of AccessControlManager\r\n     * @param accessControlManager_ The new address of the AccessControlManager\r\n     */\r\n    function _setAccessControlManager(address accessControlManager_) internal {\r\n        require(address(accessControlManager_) != address(0), \"invalid acess control manager address\");\r\n        address oldAccessControlManager = address(_accessControlManager);\r\n        _accessControlManager = IAccessControlManagerV5(accessControlManager_);\r\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if the call is not allowed by AccessControlManager\r\n     * @param signature Method signature\r\n     */\r\n    function _checkAccessAllowed(string memory signature) internal view {\r\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\r\n\r\n        if (!isAllowedToCall) {\r\n            revert(\"Unauthorized\");\r\n        }\r\n    }\r\n}"
    },
    "contracts/Governance/IAccessControlManagerV5.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n * @title IAccessControlManagerV5\r\n * @author Venus\r\n * @notice Interface implemented by the `AccessControlManagerV5` contract.\r\n */\r\ninterface IAccessControlManagerV5 {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @notice Gives a function call permission to one single account\r\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\r\n     * \t\tMay emit a {RoleGranted} event.\r\n     * @param contractAddress address of contract for which call permissions will be granted\r\n     * @param functionSig signature e.g. \"functionName(uint,bool)\"\r\n     */\r\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\r\n\r\n    /**\r\n     * @notice Revokes an account's permission to a particular function call\r\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\r\n     * \t\tMay emit a {RoleRevoked} event.\r\n     * @param contractAddress address of contract for which call permissions will be revoked\r\n     * @param functionSig signature e.g. \"functionName(uint,bool)\"\r\n     */\r\n    function revokeCallPermission(\r\n        address contractAddress,\r\n        string calldata functionSig,\r\n        address accountToRevoke\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Verifies if the given account can call a praticular contract's function\r\n     * @dev Since the contract is calling itself this function, we can get contracts address with msg.sender\r\n     * @param account address (eoa or contract) for which call permissions will be checked\r\n     * @param functionSig signature e.g. \"functionName(uint,bool)\"\r\n     * @return false if the user account cannot call the particular contract function\r\n     *\r\n     */\r\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\r\n\r\n    function hasPermission(\r\n        address account,\r\n        address contractAddress,\r\n        string calldata functionSig\r\n    ) external view returns (bool);\r\n}"
    },
    "contracts/Governance/Timelock.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Utils/SafeMath.sol\";\r\n\r\n/**\r\n * @title Timelock\r\n * @author Venus\r\n * @notice The Timelock contract.\r\n */\r\ncontract Timelock {\r\n    using SafeMath for uint;\r\n    /// @notice Event emitted when a new admin is accepted\r\n    event NewAdmin(address indexed newAdmin);\r\n\r\n    /// @notice Event emitted when a new admin is proposed\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n\r\n    /// @notice Event emitted when a new admin is proposed\r\n    event NewDelay(uint indexed newDelay);\r\n\r\n    /// @notice Event emitted when a proposal transaction has been cancelled\r\n    event CancelTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint value,\r\n        string signature,\r\n        bytes data,\r\n        uint eta\r\n    );\r\n\r\n    /// @notice Event emitted when a proposal transaction has been executed\r\n    event ExecuteTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint value,\r\n        string signature,\r\n        bytes data,\r\n        uint eta\r\n    );\r\n\r\n    /// @notice Event emitted when a proposal transaction has been queued\r\n    event QueueTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint value,\r\n        string signature,\r\n        bytes data,\r\n        uint eta\r\n    );\r\n\r\n    /// @notice Required period to execute a proposal transaction\r\n    uint public constant GRACE_PERIOD = 14 days;\r\n\r\n    /// @notice Minimum amount of time a proposal transaction must be queued\r\n    uint public constant MINIMUM_DELAY = 1 hours;\r\n\r\n    /// @notice Maximum amount of time a proposal transaction must be queued\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    /// @notice Timelock admin authorized to queue and execute transactions\r\n    address public admin;\r\n\r\n    /// @notice Account proposed as the next admin\r\n    address public pendingAdmin;\r\n\r\n    /// @notice Period for a proposal transaction to be queued\r\n    uint public delay;\r\n\r\n    /// @notice Mapping of queued transactions\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n    constructor(address admin_, uint delay_) public {\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    /**\r\n     * @notice Setter for the transaction queue delay\r\n     * @param delay_ The new delay period for the transaction queue\r\n     */\r\n    function setDelay(uint delay_) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    /**\r\n     * @notice Method for accepting a proposed admin\r\n     */\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    /**\r\n     * @notice Method to propose a new admin authorized to call timelock functions. This should be the Governor Contract\r\n     * @param pendingAdmin_ Address of the proposed admin\r\n     */\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    /**\r\n     * @notice Called for each action when queuing a proposal\r\n     * @param target Address of the contract with the method to be called\r\n     * @param value Native token amount sent with the transaction\r\n     * @param signature Ssignature of the function to be called\r\n     * @param data Arguments to be passed to the function when called\r\n     * @param eta Timestamp after which the transaction can be executed\r\n     * @return Hash of the queued transaction\r\n     */\r\n    function queueTransaction(\r\n        address target,\r\n        uint value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint eta\r\n    ) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(\r\n            eta >= getBlockTimestamp().add(delay),\r\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\r\n        );\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Called to cancel a queued transaction\r\n     * @param target Address of the contract with the method to be called\r\n     * @param value Native token amount sent with the transaction\r\n     * @param signature Ssignature of the function to be called\r\n     * @param data Arguments to be passed to the function when called\r\n     * @param eta Timestamp after which the transaction can be executed\r\n     */\r\n    function cancelTransaction(\r\n        address target,\r\n        uint value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint eta\r\n    ) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    /**\r\n     * @notice Called to execute a queued transaction\r\n     * @param target Address of the contract with the method to be called\r\n     * @param value Native token amount sent with the transaction\r\n     * @param signature Ssignature of the function to be called\r\n     * @param data Arguments to be passed to the function when called\r\n     * @param eta Timestamp after which the transaction can be executed\r\n     */\r\n    function executeTransaction(\r\n        address target,\r\n        uint value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint eta\r\n    ) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n}"
    },
    "contracts/Governance/TimeManagerV5.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity 0.5.16;\r\n\r\ncontract TimeManagerV5 {\r\n    /// @dev The approximate number of seconds per year\r\n    uint256 public constant SECONDS_PER_YEAR = 31_536_000;\r\n\r\n    /// @notice Number of blocks per year or seconds per year\r\n    uint256 public blocksOrSecondsPerYear;\r\n\r\n    /// @dev Sets true when block timestamp is used\r\n    bool public isTimeBased;\r\n\r\n    /// @dev Sets true when contract is initialized\r\n    bool private isInitialized;\r\n\r\n    /// @notice Deprecated slot for _getCurrentSlot function pointer\r\n    bytes8 private __deprecatedSlot1;\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[48] private __gap;\r\n\r\n    /**\r\n     * @dev Function to simply retrieve block number or block timestamp\r\n     * @return Current block number or block timestamp\r\n     */\r\n    function getBlockNumberOrTimestamp() public view returns (uint256) {\r\n        return isTimeBased ? _getBlockTimestamp() : _getBlockNumber();\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract to use either blocks or seconds\r\n     * @param timeBased_ A boolean indicating whether the contract is based on time or block\r\n     * If timeBased is true than blocksPerYear_ param is ignored as blocksOrSecondsPerYear is set to SECONDS_PER_YEAR\r\n     * @param blocksPerYear_ The number of blocks per year\r\n     */\r\n    function _initializeTimeManager(bool timeBased_, uint256 blocksPerYear_) internal {\r\n        if (isInitialized) revert(\"Already initialized TimeManager\");\r\n\r\n        if (!timeBased_ && blocksPerYear_ == 0) {\r\n            revert(\"Invalid blocks per year\");\r\n        }\r\n        if (timeBased_ && blocksPerYear_ != 0) {\r\n            revert(\"Invalid time based configuration\");\r\n        }\r\n\r\n        isTimeBased = timeBased_;\r\n        blocksOrSecondsPerYear = timeBased_ ? SECONDS_PER_YEAR : blocksPerYear_;\r\n        isInitialized = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current timestamp in seconds\r\n     * @return The current timestamp\r\n     */\r\n    function _getBlockTimestamp() private view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current block number\r\n     * @return The current block number\r\n     */\r\n    function _getBlockNumber() private view returns (uint256) {\r\n        return block.number;\r\n    }\r\n}"
    },
    "contracts/Utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}"
    },
    "contracts/Utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin Contracts v4.3.2 (utils/cryptography/ECDSA.sol)\r\n\r\n// SPDX-Copyright-Text: OpenZeppelin, 2021\r\n// SPDX-Copyright-Text: Venus, 2021\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\ncontract ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n Ã· 2 + 1, and for v in (302): v âˆˆ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n}"
    },
    "contracts/Utils/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
    },
    "contracts/Utils/SafeCast.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2 ** 128, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2 ** 64, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2 ** 32, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2 ** 16, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2 ** 8, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2 ** 127 && value < 2 ** 127, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2 ** 63 && value < 2 ** 63, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2 ** 31 && value < 2 ** 31, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2 ** 15 && value < 2 ** 15, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2 ** 7 && value < 2 ** 7, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2 ** 255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}"
    },
    "contracts/Utils/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}"
    },
    "contracts/Utils/SafeMath.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(a, b, \"SafeMath: addition overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}